<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Redis in 1024 lines of code</title>
	<link rel="stylesheet" href="prism.css">
	<link rel="stylesheet" href="style.css">
</head>
<script src="prism.js"></script>

<body>
	<header>
		<div class="header-content">
			<a href="/"><img src="profile.png" alt="profile picture" height="32"></a>
			<a href="/" class="name">Michael Lesniak</a>
			<span class="right">
				<a href="/about.html">About me</a>
				<a href="mailto:mail@mlesniak.com">Email</a>
				<a href="https://github.com/mlesniak"> GitHub </a>
			</span>
		</div>
	</header>

	<article>
				<h1 class="title">Redis in 1024 lines of code</h1>
						<p>This article describes my approach to write a Redis clone in C#,
limiting myself to 1024 lines of code (as stated by the code analysis
tool <a href="https://github.com/AlDanial/cloc">cloc</a>). A similar
approach for various topics has been discussed in books such as <a
href="https://amzn.eu/d/b4iJBIa">500 Lines or Less</a>.</p>
<h2 id="the-goal">The goal</h2>
<p>The aim is to allow the official Redis CLI tool to interface with our
server and execute as many standard-compliant operations as possible. As
a twist in this experiment, I will be using a test-driven approach as
much as possible and will write the code in parallel to the blog post –
expect refactoring and questioning of design decisions in later stages
of the post…</p>
<h2 id="the-beginning">The beginning</h2>
<p>While I could have commenced by diving into the protocol
specification and building the server accordingly, I felt that might be
somewhat mundane. Instead, I opted to initiate a basic TCP server, set
it to listen on port 6379 (the standard port for Redis), and observe the
commands the client transmits.</p>
<p>After setting up a project with
<code>dotnet new console -o src</code>, let’s spawn up a simple TCP
server which simply output what it has received</p>
<pre><code class="language-cs">// Program.cs
using System.Net.Sockets;

TcpListener server = new(6379);
server.Start();
Console.WriteLine(&quot;Server started&quot;);
while (true)
{
    TcpClient client = server.AcceptTcpClient();
    Console.WriteLine(&quot;Client connected&quot;);
    var stream = client.GetStream();

    byte[] buffer = new byte[1024];
    int read = stream.Read(buffer);
    foreach (byte b in buffer.Take(read))
    {
        Console.Write((char)b);
    }
    Console.WriteLine();
    client.Close();
}</code></pre>
<p>Subsequently, we’ll start the redis-cli through the default Docker
image:</p>
<pre><code class="language-bash">docker run --rm -it redis redis-cli -h docker.for.mac.localhost</code></pre>
<p>The printout from the TCP server reveals the incoming data:</p>
<pre><code class="language-bash">Server started
Client connected
*2
$7
COMMAND
$4
DOCS</code></pre>
<p>Revisiting the protocol specification, it becomes evident that the
client dispatches an array containing two components. Each of these is a
bulk string. Essentially, the client is requesting the server to furnish
a list of supported commands along with their respective
documentation.</p>
<h2 id="parsing-bulk-strings">Parsing bulk strings</h2>
<!-- setting up a test project -->
<p>I intentionally want to completely separate the actual implementation
for its corresponding tests. Therefore let’s setup a test project using
<a href="https://xunit.net/">xUnit</a> via
<code>dotnet new xunit -o test</code> in the parent directory of the
source code.</p>
<!-- test for bulk string -->
<p>The first test to verify correct parsing of bulk strings looks
like</p>
<pre><code class="language-cs">[Fact]
public void ToRedisMessage_SimpleBulkString_ReturnsCorrectResult()
{
    var message = &quot;&quot;&quot;
                  $5
                  HELLO
                  &quot;&quot;&quot;.ToRedisMessage();
    
    var data = RedisData.Parse(message);

    Equal(RedisData.RedisDataType.BulkString, data.Type);
    Equal(&quot;HELLO&quot;, data.BulkString);
}</code></pre>
<p>As you can see by the test, a bulk string consists of a
<code>$</code> and a number stating the number of bytes to follow which
will build up the string. Implicitly stated, but hidden in the string
representation is the delimiter between elements,
i.e. <code>\r\n</code>.</p>
<!-- initial data structure -- will probably change -->
<p>To represent the received input, and generate corresponding output
later on, let’s start with a basic data structure which will probably be
changed a lot once we gain more insights.</p>
<pre><code class="language-cs">public class RedisData
{
    public enum RedisDataType
    {
        Array,
        BulkString,
    }

    public RedisDataType Type { get; set; }
    public string? BulkString { get; set; } = null;
    public List&lt;RedisData&gt;? ArrayValues { get; set; } = null;

    public static RedisData Parse(byte[] data)
    {
        (RedisData result, _) = Parse(data, 0);
        return result;
    }

    // return (parsed data, beginning of next element)
    static (RedisData, int) Parse(byte[] data, int offset)
    {
        // TODO
    }</code></pre>
<p>Currently, only (nested) arrays and bulk strings will be supported by
our parsing routine <code>Parse()</code>. Internally, it calls its
counterpart which allows to specify the starting point for parsing which
is necessary for sequential structures such as arrays.</p>
<!-- implementation -- leave out arrays for now -->
<p>Ignoring parsing arrays for now – overall, we focus on a somewhat
test-driven approach and our tests focus on bulk strings for now – we
can parse bulk strings as follows:</p>
<pre><code class="language-cs">static (RedisData, int) Parse(byte[] data, int offset)
{
    RedisData result = new();
    int end = 0;
    
    if (data[offset] == &#39;*&#39;)
    {
        throw new NotImplementedException();
    }
    else if (data[offset] == &#39;$&#39;)
    {
        result.Type = RedisDataType.BulkString;
        var lengthEnd = Array.IndexOf(data, (byte)&#39;\r&#39;, offset);
        var length = Int32.Parse(Encoding.ASCII.GetString(data, offset + 1, lengthEnd - offset - 1));
        int stringStart = lengthEnd + 2;
        result.BulkString = Encoding.ASCII.GetString(data, stringStart, length);
        nextOffset = stringStart + length + 2;
    }
    else
    {
        throw new ArgumentException($&quot;Invalid byte {data[offset]} to parse&quot;);
    }

    return (result, end);
}</code></pre>
<p>Note that the internal implementation will be refactored once our
basic test cases are working.</p>
<h2 id="parsing-arrays">Parsing arrays</h2>
<p>We can use a similar approach to parse arrays, though arrayc are
recursive data structures in the redis protocol and can contain both
plain values, e.g. bulk strings, as nested arrays. Hence, let’s define
two different test cases: The first one mirrors the data we receive from
the client and will allow to parse sent commands, the second checks that
the implementation handles nested arrays correctly:</p>
<pre><code class="language-cs">[Fact]
public void ToRedisMessage_SimpleArray_ReturnsCorrectResult()
{
    var message = &quot;&quot;&quot;
                    *2
                    $5
                    HELLO
                    $3
                    FOO
                    &quot;&quot;&quot;.ToRedisMessage();
    
    var data = RedisData.Parse(message);
    
    Equal(RedisData.RedisDataType.Array, data.Type);
    
    Equal(RedisData.RedisDataType.BulkString, data.ArrayValues![0].Type);
    Equal(&quot;HELLO&quot;, data.ArrayValues![0].BulkString);
    
    Equal(RedisData.RedisDataType.BulkString, data.ArrayValues![1].Type);
    Equal(&quot;FOO&quot;, data.ArrayValues![1].BulkString);
}

[Fact]
public void ToRedisMessage_NestedArray_ReturnsCorrectResult()
{
    var message = &quot;&quot;&quot;
                    *2
                    *2
                    $3
                    BAR
                    $5
                    HELLO
                    $3
                    FOO
                    &quot;&quot;&quot;.ToRedisMessage();
    
    var data = RedisData.Parse(message);
    
    Equal(RedisData.RedisDataType.Array, data.Type);
    
    Equal(RedisData.RedisDataType.Array, data.ArrayValues![0].Type);
    var array = data.ArrayValues![0];
    Equal(&quot;BAR&quot;, array.ArrayValues?[0].BulkString);
    Equal(&quot;HELLO&quot;, array.ArrayValues?[1].BulkString);
    
    Equal(RedisData.RedisDataType.BulkString, data.ArrayValues![1].Type);
    Equal(&quot;FOO&quot;, data.ArrayValues?[1].BulkString);
}</code></pre>
<p>This can be implemented via the following snippet inside
<code>Parse()</code></p>
<pre><code class="language-cs">    if (data[offset] == &#39;*&#39;)
    {
        result.Type = RedisDataType.Array;
        result.ArrayValues = new();
        var numElementsIndexEnd = Array.IndexOf(data, (byte)&#39;\r&#39;, offset);
        var numElements = Int32.Parse(Encoding.ASCII.GetString(data, offset + 1, numElementsIndexEnd - offset - 1));
        offset = numElementsIndexEnd + 2;
        for (var i = 0; i &lt; numElements; i++)
        {
            (RedisData elem, int nextArrayOffset) = Parse(data, offset);
            result.ArrayValues.Add(elem);
            offset = nextArrayOffset;
        }
        nextOffset = offset;
    }</code></pre>
<p>Since we now have a basic test setup, let’s refactor the code a bit
by moving away from this <code>if-else</code> cascade and introduce a
switch statement and move the type-defining character to the enum.</p>
<h3 id="a-short-excursion-into-over-engineering">A short excursion into
over-engineering</h3>
<p>We want to implement a more general approach the if-else-cascade,
though one can rightfully argue that this is not the worst code to
maintain. Nonetheless, a <code>switch</code> statement would be possible
as well. For that, we have to add a custom attribute which stores the
corresponding encoding character for each data type:</p>
<pre><code class="language-cs">[AttributeUsage(AttributeTargets.Field)]
sealed class ByteRepresentationAttribute : Attribute
{
    public byte Byte { get; }

    public ByteRepresentationAttribute(char b)
    {
        Byte = (byte)b;
    }
}</code></pre>
<p>This allows to annotate the data type definition via</p>
<pre><code class="language-cs">public enum RedisDataType
{
    [ByteRepresentation(&#39;*&#39;)]
    Array,
    [ByteRepresentation(&#39;$&#39;)]
    BulkString,
}</code></pre>
<p>and retrieve the corresponding field from the type via an extension
function</p>
<pre><code class="language-cs">public static class DataTypeIdentifier
{
    public static byte Identifier(this RedisDataType type)
    {
        var fieldInfo = type.GetType().GetField(type.ToString())!;
        var attribute =
            ((ByteRepresentationAttribute)fieldInfo.GetCustomAttribute(typeof(ByteRepresentationAttribute))!);
        return attribute.Byte;
    }
}</code></pre>
<p>This looks – on the first look – like a nice solution and we can
refactor the if-conditions into a switch statement</p>
<pre><code class="language-cs">switch (data[offset])
{
    case var b when b == RedisDataType.BulkString.Identifier():
        // ...
        break;
    case var b when b == RedisDataType.Array.Identifier():
        // ...
        break;
    default:
        throw new ArgumentException($&quot;Invalid byte {data[offset]} to parse&quot;);
}</code></pre>
<p>where the problem becomes (in my humble view) obvious: while the
switch looks syntactically simpler, the necessary
<code>var b when b == ...</code> construct does not look very nice and
quite a bit convoluted. Note that we can not remove the section before
the <code>when</code>, since the <code>Identifier()</code> call is
dynamic and the case expression needs static values.</p>
<!-- new section back to good code -->
<p>A slightly better approach, which allows for more extensibility in
the future, is to use a dictionary in combination with a proper delegate
definition. One can argue that we do not follow <a
href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it#:~:text=%22You%20aren&#39;t%20gonna%20need,add%20functionality%20until%20deemed%20necessary.">YAGNI</a>,
but bear with me for a minute.</p>
	</article>
</body>

</html>
